"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _objectsHTML = /*#__PURE__*/new WeakMap();
var _configs = /*#__PURE__*/new WeakMap();
var _Tabs_brand = /*#__PURE__*/new WeakSet();
var Tabs = /*#__PURE__*/_createClass(function Tabs(configs) {
  _classCallCheck(this, Tabs);
  /**
   * Initial tabs functionality.
   */
  _classPrivateMethodInitSpec(this, _Tabs_brand);
  _classPrivateFieldInitSpec(this, _objectsHTML, {});
  _classPrivateFieldInitSpec(this, _configs, {
    contextID: 'tabs',
    classes: {
      tabsNavContainer: '.tabs__nav',
      tabsNavList: '.tabs__nav-list',
      tabsNavButton: '.tabs__nav-btn',
      tabPanel: '.tab-panel',
      tabPanelTitle: '.tab-panel__title'
    },
    selectors: {
      tabPanelIdPrefix: 'tabpanel',
      tabPanelOpen: 'tab-panel--open'
    },
    options: {
      useCustomNav: false,
      customNavTitles: [],
      initSelectedItem: 0,
      removeTabPanelTitle: false
    }
  });
  _classPrivateFieldSet(_configs, this, _assertClassBrand(_Tabs_brand, this, _deepMerge).call(this, _classPrivateFieldGet(_configs, this), configs));
  _assertClassBrand(_Tabs_brand, this, _initElements).call(this);
  _assertClassBrand(_Tabs_brand, this, _initTabs).call(this);
  if (_classPrivateFieldGet(_configs, this).options.removeTabPanelTitle) {
    _assertClassBrand(_Tabs_brand, this, _removeTabPanelTitle).call(this);
  }
});
function _initTabs() {
  _assertClassBrand(_Tabs_brand, this, _insertNav).call(this);
  var tab_buttons = _classPrivateFieldGet(_objectsHTML, this)['tabsNavBtn'];
  for (var i = 0; i < tab_buttons.length; i++) {
    var tab_panel = document.getElementById(tab_buttons[i].getAttribute('aria-controls'));
    tab_buttons[i].tabIndex = parseInt(_classPrivateFieldGet(_configs, this).options.initSelectedItem) === i ? 0 : -1;
    tab_buttons[i].addEventListener('keydown', _assertClassBrand(_Tabs_brand, this, _onKeyDown).bind(this));
    tab_buttons[i].addEventListener('click', _assertClassBrand(_Tabs_brand, this, _onClick).bind(this));
  }
  _assertClassBrand(_Tabs_brand, this, _prepareTabContent).call(this);
}
/**
 * Do appropriate action based on click event.
 *
 * @param {PointerEvent} event
 *   Click event.
 */
function _onClick(event) {
  var new_tab = event.currentTarget;
  var old_tab = document.querySelector("#".concat(_classPrivateFieldGet(_configs, this).contextID, " [aria-selected = \"true\"]"));
  _assertClassBrand(_Tabs_brand, this, _setSelectedTab).call(this, old_tab, new_tab);
}
/**
 * Do appropriate action based on key event.
 *
 * @param {KeyboardEvent} event
 *   Keydown event.
 */
function _onKeyDown(event) {
  var target = event.currentTarget;
  var flag = false;
  switch (event.key) {
    case 'ArrowLeft':
      _assertClassBrand(_Tabs_brand, this, _setSelectedToPreviousTab).call(this, target);
      flag = true;
      break;
    case 'ArrowRight':
      _assertClassBrand(_Tabs_brand, this, _setSelectedToNextTab).call(this, target);
      flag = true;
      break;
    case 'Home':
      _assertClassBrand(_Tabs_brand, this, _setSelectedTab).call(this, target);
      flag = true;
      break;
    case 'End':
      _assertClassBrand(_Tabs_brand, this, _setSelectedTab).call(this, target);
      flag = true;
      break;
  }
  if (flag) {
    event.stopPropagation();
    event.preventDefault();
  }
}
/**
 * Select previous tab.
 *
 * @param {HTMLElement} target
 *   Clicked nav button.
 */
function _setSelectedToPreviousTab(target) {
  var tab_buttons = _classPrivateFieldGet(_objectsHTML, this)['tabsNavBtn'];
  var current_tab_index = _assertClassBrand(_Tabs_brand, this, _getClickedTabIndex).call(this, tab_buttons, target);
  var new_current_tab = _assertClassBrand(_Tabs_brand, this, _getPreviousTab).call(this, current_tab_index, tab_buttons);
  _assertClassBrand(_Tabs_brand, this, _setSelectedTab).call(this, target, new_current_tab);
}
/**
 * Select next tab.
 *
 * @param {HTMLElement} target
 *   Clicked nav button.
 */
function _setSelectedToNextTab(target) {
  var tab_buttons = _classPrivateFieldGet(_objectsHTML, this)['tabsNavBtn'];
  var current_tab_index = _assertClassBrand(_Tabs_brand, this, _getClickedTabIndex).call(this, tab_buttons, target);
  var new_current_tab = _assertClassBrand(_Tabs_brand, this, _getNextTab).call(this, current_tab_index, tab_buttons);
  _assertClassBrand(_Tabs_brand, this, _setSelectedTab).call(this, target, new_current_tab);
}
/**
 * Toggle tab panel.
 *
 * @param {HTMLElement} old_tab
 *   Old tab element.
 *
 * @param {HTMLElement} new_tab
 *   New tab element.
 */
function _setSelectedTab(old_tab, new_tab) {
  var old_panel_tab_id = old_tab.getAttribute(['aria-controls']);
  var new_panel_tab_id = new_tab.getAttribute(['aria-controls']);
  old_tab.setAttribute('aria-selected', 'false');
  old_tab.tabIndex = -1;
  new_tab.setAttribute('aria-selected', 'true');
  new_tab.tabIndex = 1;
  new_tab.focus();
  _assertClassBrand(_Tabs_brand, this, _toggleTabContent).call(this, old_panel_tab_id, new_panel_tab_id);
}
/**
 * Get previous tab element.
 *
 * @param {number} current_tab_index
 *   Current tab index.
 *
 * @param {NodeList} tab_buttons
 *   Nav buttons.
 *
 * @returns HTMLElement
 *   Return previous tab.
 */
function _getPreviousTab(current_tab_index, tab_buttons) {
  return current_tab_index > 0 ? tab_buttons[current_tab_index - 1] : tab_buttons[tab_buttons.length - 1];
}
/**
 * Get next tab element.
 *
 * @param {number} current_tab_index
 *   Current tab index.
 *
 * @param {NodeList} tab_buttons
 *   Nav buttons.
 *
 * @returns HTMLElement
 *   Return next tab.
 */
function _getNextTab(current_tab_index, tab_buttons) {
  return current_tab_index < tab_buttons.length - 1 ? tab_buttons[current_tab_index + 1] : tab_buttons[0];
}
/**
 * Prepared tab content by adding appropriate attributes.
 */
function _prepareTabContent() {
  var _this = this;
  if (_classPrivateFieldGet(_objectsHTML, this)['tabPanel'].length === 0) {
    throw new Error("[tabs plugin] tab panels should exist.");
  }
  _classPrivateFieldGet(_objectsHTML, this)['tabPanel'].forEach(function (item, index) {
    var tab_panel_id = _classPrivateFieldGet(_configs, _this).selectors.tabPanelIdPrefix + '-' + index;
    var open_class_selector = _classPrivateFieldGet(_configs, _this).selectors.tabPanelOpen;
    var tab_panel_open_index = _classPrivateFieldGet(_configs, _this).options.initSelectedItem;
    item.setAttribute('id', tab_panel_id);
    item.setAttribute('tabindex', '0');
    if (tab_panel_open_index === index) {
      item.classList.add(open_class_selector);
    }
  });
}
/**
 * Toggle open tab panel css class.
 *
 * @param {string} old_panel_tab_id
 *   Old panel tab id name.
 *
 * @param {string} new_panel_tab_id
 *   New panel tab id name.
 */
function _toggleTabContent(old_panel_tab_id, new_panel_tab_id) {
  var open_selector = _classPrivateFieldGet(_configs, this).selectors.tabPanelOpen;
  document.getElementById(old_panel_tab_id).classList.remove(open_selector);
  document.getElementById(new_panel_tab_id).classList.add(open_selector);
}
/**
 * Get clicked nav button index.
 *
 * @param {NodeList} tab_buttons
 *   Nav buttons.
 *
 * @param {HTMLElement} target
 *   Clicked nav button.
 *
 * @returns {number}
 *   Return current clicked nav button index.
 */
function _getClickedTabIndex(tab_buttons, target) {
  return Array.from(tab_buttons).findIndex(function (item) {
    return item.getAttribute('aria-controls') === target.getAttribute('aria-controls');
  });
}
/**
 * Prepare and insert tab navigation.
 */
function _insertNav() {
  if (!_classPrivateFieldGet(_configs, this).options.useCustomNav) {
    _classPrivateFieldGet(_objectsHTML, this)['tabsNavContainer'][0].innerHTML = _assertClassBrand(_Tabs_brand, this, _createNav).call(this);
  } else {
    _assertClassBrand(_Tabs_brand, this, _preparedCustomNavButton).call(this);
  }
  _assertClassBrand(_Tabs_brand, this, _appendElement).call(this, 'tabsNavBtn', document.querySelectorAll("#".concat(_classPrivateFieldGet(_configs, this).contextID, " [role = \"tab\"]")));
}
/**
 * Remove title from tab panel.
 */
function _removeTabPanelTitle() {
  _classPrivateFieldGet(_objectsHTML, this)['tabPanelTitle'].forEach(function (item) {
    item.remove();
  });
}
/**
 * Get nav title.
 *
 * @param {number} index
 *   Nav title index.
 *
 * @returns {string}
 *   Return title string.
 */
function _getNavTitle(index) {
  var title = '';
  if (_classPrivateFieldGet(_configs, this).options.customNavTitles.length) {
    title = _classPrivateFieldGet(_configs, this).options.customNavTitles[index];
  } else {
    var custom_title = _classPrivateFieldGet(_objectsHTML, this)['tabPanelTitle'][index].getAttribute('data-nav-title');
    title = custom_title !== null && custom_title !== void 0 ? custom_title : _classPrivateFieldGet(_objectsHTML, this)['tabPanelTitle'][index].innerText;
  }
  if (title === undefined) {
    title = '';
  }
  return title;
}
/**
 * Create default raw nav HTML.
 *
 * @returns {string}
 *   Return raw nav HTML.
 */
function _createNav() {
  var tab_nav_list_selector = _classPrivateFieldGet(_configs, this).classes.tabsNavList.substring(1);
  var tab_nav_btn_selector = _classPrivateFieldGet(_configs, this).classes.tabsNavButton.substring(1);
  var html = "<div class=\"".concat(tab_nav_list_selector, "\" role=\"tablist\">");
  for (var i = 0; i < _classPrivateFieldGet(_objectsHTML, this)['tabPanelTitle'].length; i++) {
    var tab_panel_id = _classPrivateFieldGet(_configs, this).selectors.tabPanelIdPrefix + '-' + i;
    var is_selected = parseInt(_classPrivateFieldGet(_configs, this).options.initSelectedItem) === i;
    html += "<button class=\"".concat(tab_nav_btn_selector, "\" role=\"tab\" aria-selected=\"").concat(is_selected ? 'true' : 'false', "\" aria-controls=\"").concat(tab_panel_id, "\">").concat(_assertClassBrand(_Tabs_brand, this, _getNavTitle).call(this, i), "</button>");
  }
  html += '</div>';
  return html;
}
/**
 * Prepared custom nav buttons by adding aria attributes.
 */
function _preparedCustomNavButton() {
  for (var i = 0; i < _classPrivateFieldGet(_objectsHTML, this)['tabsNavButton'].length; i++) {
    var tab_panel_id = _classPrivateFieldGet(_configs, this).selectors.tabPanelIdPrefix + '-' + i;
    var is_selected = parseInt(_classPrivateFieldGet(_configs, this).options.initSelectedItem) === i;
    _classPrivateFieldGet(_objectsHTML, this)['tabsNavButton'][i].setAttribute('aria-controls', tab_panel_id);
    _classPrivateFieldGet(_objectsHTML, this)['tabsNavButton'][i].setAttribute('aria-selected', 'false');
    if (is_selected) {
      _classPrivateFieldGet(_objectsHTML, this)['tabsNavButton'][i].setAttribute('aria-selected', 'true');
    }
  }
}
/**
 * Init HTML element based on configs css class selectors.
 */
function _initElements() {
  var classes = _classPrivateFieldGet(_configs, this).classes;
  var context = document.getElementById(_classPrivateFieldGet(_configs, this).contextID);
  if (!context) {
    throw new Error("[tabs plugin] contextID does not exist in html structure.");
  }
  for (var el in classes) {
    var selectors = context.querySelectorAll(classes[el]);
    if (selectors.length === 0) {
      continue;
    }
    _classPrivateFieldGet(_objectsHTML, this)[el] = selectors;
  }
}
/**
 * Append NodeList elements to array.
 *
 * @param {string} name
 *   Element name.
 *
 * @param {NodeList} value
 *   HTML node list.
 */
function _appendElement(name, value) {
  _classPrivateFieldGet(_objectsHTML, this)[name] = value;
}
/**
 * Merge deep two objects.
 *
 * @param {object} obj1
 *   Initial first object
 *
 * @param {object} obj2
 *   Second object to be merged to the first one.
 *
 * @returns {object}
 *   Return merged object.
 */
function _deepMerge(obj1, obj2) {
  var result = _objectSpread({}, obj1);
  for (var key in obj2) {
    if (obj2.hasOwnProperty(key)) {
      if (Array.isArray(obj2[key]) && Array.isArray(obj1[key])) {
        // If both are arrays, concatenate them or handle as needed
        result[key] = obj1[key].concat(obj2[key]);
      } else if (obj2[key] instanceof Object && obj1[key] instanceof Object) {
        // If both are objects, merge them recursively
        result[key] = _assertClassBrand(_Tabs_brand, this, _deepMerge).call(this, obj1[key], obj2[key]);
      } else {
        // Otherwise, just assign the value from obj2 to the result
        result[key] = obj2[key];
      }
    }
  }
  return result;
}
if (typeof module !== 'undefined' && module.exports) {
  module.exports = Tabs;
}